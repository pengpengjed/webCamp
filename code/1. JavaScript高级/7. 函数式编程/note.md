# 函数式编程思想

引子：我们如何从面向对象编程思想演变

## 面向对象编程思想

在很早期前端还没有成熟的模块化的时候，我们就是使用命名空间

```
const $ = {}
```

模块化思想 + 面向对象编程思想方式去优化

## 函数式编程思想

目前 react、vue3 提倡的 hook 的思想，（代数模型，复用的逻辑，传递性，乘法交换律结合律）
hook 本质就是函数式编程

> 面试：函数式编程思想相较于面向对象编程思想的优势，你的看法

1. 复用更灵活
2. 可测试性更高
3. 高度解耦（UI、state）
4. hook 写法的优势对比于 optional api

## 正式学习函数式

函数为一等公民

封装一定首先想到的是老大 —— 函数

面向对象编程 —— 继承实现封装
函数式编程 —— 组合实现封装

这两个是给大家补充的内容：
面向切面编程 —— interceptor（拦截器）AOP（aspect oriented program 前面那节课 类似于 axios 的封装）
微内核 —— 插件化机制

拦截器不会影响主体功能核心
微内核会增强主体 webpack plugin 是不是可以增强输出

### 为什么用函数式编程思想

1. 函数和对象来比较，函数是不是很简单，是不是可以预知一些东西

```js
function sum(a, b) {
  return a + b;
}

sum(1, 2);
// 函数式编程，这个函数称之为纯函数
```

我只要保证函数名、函数参数不变，那么结果是不是一定不变？**是的**

什么不是纯函数

纯函数的定义：

> 相同入参一定得到相同结果

### 纯函数

纯函数的定义：

> 相同入参一定得到相同结果

影响结果，称为副作用

<!-- async await React Suspense 的思路 -->

### 函数式编程几大特性

1. 可缓存性（相同的入参我们是可以判断的）
2. 可移植性
3. 可测试
4. 可并行，为什么有副作用的函数不好并行？（java 多线程，线程**锁**）

```js
let c = 0;

// 是纯函数？不是
const fn1 = async (a) => {
  await sleep(100);
  c += a; // 改了
  return c;
};
// 是纯函数？不是
const fn2 = async (b) => {
  await sleep(100);
  c -= b; // 改了
  return c;
};

Promise.all([fn1, fn2]);
```

### 柯里化

闭包的应用，子作用域中访问父作用域内容的表现

#### 函数柯里化的应用

1. 代数模型
2. compose
