<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // åŸºæœ¬å†™æ³•
      function sleepPromise(time) {
        // å¤–éƒ¨ä¸ä¼šç›´æŽ¥ä¼ å…¥ resolve å’Œ reject
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve();
          }, time);
        });
      }

      // æ‰‹åŠ¨å®žçŽ°
      class HeyiPromise {
        resolvers = [];
        rejecters = [];

        initValue() {
          // åˆå§‹åŒ–å€¼
          this.PromiseResult = null; // ç»ˆå€¼
          this.PromiseState = "pending"; // çŠ¶æ€
        }

        initBind() {
          // å¦‚æžœæˆ‘ä»¬æ˜¯ä½¿ç”¨ OOPï¼ˆé¢å‘å¯¹è±¡ç¼–ç¨‹æ€æƒ³ï¼‰å°è£…çš„è¯ï¼Œæˆ‘ä»¬è¦æ—¶åˆ»å…³æ³¨ä¸Šä¸‹æ–‡ï¼ˆctxï¼‰ï¼Œthis çš„æŒ‡å‘
          // åˆå§‹åŒ–this
          this._resolve = this._resolve.bind(this);
          this._reject = this._reject.bind(this);
        }

        constructor(executor) {
          // åˆå§‹åŒ– Promise çš„ä¸€äº›åŸºç¡€æ•°æ®
          // 1. åˆå§‹åŒ– Promise çŠ¶æ€
          // 2. åˆå§‹åŒ– Promise ç»ˆå€¼
          this.initValue();
          // è¿›è¡Œ this ç»‘å®šå¤„ç†
          this.initBind();

          executor(this._resolve, this._reject);
        }

        // ç”¨äºŽåŽ»æ”¶é›†æˆåŠŸçš„å›žè°ƒå‡½æ•°
        _resolve(value) {
          // å¤„ç†çŠ¶æ€ä¸å¯é€†
          if (this.PromiseState !== "pending") return;
          this.PromiseState = "fulfilled";
          this.PromiseResult = value;
          this.resolvers.forEach((fn) => fn(value));
        }

        // ç”¨äºŽåŽ»æ”¶é›†å¤±è´¥çš„å›žè°ƒå‡½æ•°
        _reject(reason) {
          if (this.PromiseState !== "pending") return;
          this.PromiseState = "rejected";
          this.PromiseResult = reason;
          this.rejecters.forEach((fn) => fn(reason));
        }

        then(onFulfilled, onRejected) {
          // æŽ¥æ”¶ä¸¤ä¸ªå›žè°ƒ onFulfilled, onRejected

          // å‚æ•°æ ¡éªŒå¤„ç†
          // å‚æ•°æ ¡éªŒï¼Œç¡®ä¿ä¸€å®šæ˜¯å‡½æ•°
          onFulfilled =
            typeof onFulfilled === "function" ? onFulfilled : (val) => val;
          onRejected =
            typeof onRejected === "function"
              ? onRejected
              : (reason) => {
                  throw reason;
                };

          // é“¾å¼è°ƒç”¨
          const thenPromise = new HeyiPromise((resolve, reject) => {
            const resolvePromise = (cb) => {
              try {
                const x = cb(this.PromiseResult);
                // åˆ¤æ–­ x çš„å€¼æ˜¯æ™®é€šå€¼è¿˜æ˜¯ promise å¯¹è±¡
                if (x === thenPromise && x) {
                  // å¦‚æžœ x === thenPromiseï¼Œé‚£ä¹ˆå°±ä¼šé€ æˆæ­»å¾ªçŽ¯
                  throw new Error("ä¸èƒ½è¿”å›žåŒä¸€ä¸ª promise");
                }
                // æ˜¯å¦æ˜¯ HeyiPromise çš„å®žä¾‹
                if (x instanceof HeyiPromise) {
                  x.then(resolve, reject);
                } else {
                  resolve(x);
                }
              } catch (error) {
                reject(error);
                throw new Error(error);
              }
            };
            if (this.PromiseState === "fulfilled") {
              // å¦‚æžœå½“å‰ä¸ºæˆåŠŸçŠ¶æ€ï¼Œæ‰§è¡Œç¬¬ä¸€ä¸ªå›žè°ƒ
              resolvePromise(onFulfilled);
            } else if (this.PromiseState === "rejected") {
              // å¦‚æžœå½“å‰ä¸ºå¤±è´¥çŠ¶æ€ï¼Œæ‰§è¡Œç¬¬äºŒå“¥å›žè°ƒ
              resolvePromise(onRejected);
            } else if (this.PromiseState === "pending") {
              // å¦‚æžœå½“å‰ä¸ºpendingçŠ¶æ€ï¼Œä¿å­˜å›žè°ƒå‡½æ•°
              this.resolvers.push((result) => resolvePromise(onFulfilled));
              this.rejecters.push((reason) => resolvePromise(onRejected));
            }
          });

          return thenPromise;
        }

        catch() {
          console.log("catch");
        }

        finally() {
          console.log("finally");
        }
      }
      function sleepHeyiPromise(time) {
        return new HeyiPromise((resolve, reject) => {
          setTimeout(() => {
            resolve();
          }, time);
        });
      }
      const result = sleepHeyiPromise(1000);
      console.log("ðŸš€ ~ file: 3.promise.html:34 ~ result:", result);
      result
        .then(() => {
          console.log("æˆ‘æ˜¯ result then");
        })
        .then(() => {
          console.log("æˆ‘æ˜¯ result then 2");
        });
      // .catch(() => {
      //   console.log("æˆ‘æ˜¯ result catch");
      // });
    </script>
  </body>
</html>
